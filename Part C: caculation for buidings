from datetime import datetime
from meteostat import Point, Hourly
import numpy as np
import yaml
import matplotlib.pyplot as plt
import requests


# Define the location (Edinburgh: 55.9533° N, 3.1883° W)
location = Point(55.9533, -3.1883)

# Set the time period for data retrieval
start = datetime(2023, 1, 1, 0) # Start time
end = datetime(2023, 1, 2, 0) # End time (24-hour period)

# Fetch hourly temperature data
data = Hourly(location,start,end)
data = data.fetch()
data = data.reset_index()
t_ambient = []
hours = data["time"].dt.hour
for i in range(0,25):
    t = data["temp"].iloc[i] + 273 
    t_ambient.append(t)
'''   
#---------------------------------------------------------------------------------------
# Load the YAML file directly from github
'''

inputs_file = "https://raw.githubusercontent.com/erikasdaniels/CMM3-Group-24-Project/refs/heads/main/inputs.yaml"

response_inputs = requests.get(inputs_file)

if response_inputs.status_code == 200:
        data_inputs = yaml.safe_load(response_inputs.text)
        
# Define the URL of the YAML file
inputs_buildings_file = "https://github.com/erikasdaniels/CMM3-Group-24-Project/blob/main/BUILDING_VALUES.yaml"

# Request to get the file from GitHub
response_inputs_buildings = requests.get(inputs_buildings_file)

# Check if the request was successful
if response_inputs_buildings.status_code == 200:
    # Parse the YAML content
    data_inputs_buildings = yaml.safe_load(response_inputs_buildings.text)
'''
#---------------------------------------------------------------------------------------------------
'''   
    # Extract specific values into variables

fixed_condenser_temperature = data_inputs['heat_pump']['fixed_condenser_temperature_K']['value']
heat_transfer_area = data_inputs['heat_pump']['heat_transfer_area']['value']
off_temperature_threshold = data_inputs['heat_pump']['off_temperature_threshold_K']['value']
on_temperature_threshold = data_inputs['heat_pump']['on_temperature_threshold_K']['value']
overall_heat_transfer_coefficient = data_inputs['heat_pump']['overall_heat_transfer_coefficient']['value']

heat_loss_coefficient = data_inputs['hot_water_tank']['heat_loss_coefficient']['value']
mass_of_water = data_inputs['hot_water_tank']['mass_of_water']['value']
specific_heat_capacity = data_inputs['hot_water_tank']['specific_heat_capacity']['value']
total_thermal_capacity = data_inputs['hot_water_tank']['total_thermal_capacity']['value']

initial_tank_temperature = data_inputs['initial_conditions']['initial_tank_temperature_K']['value']

time_step = data_inputs['simulation_parameters']['time_points']['value']
total_time = data_inputs['simulation_parameters']['total_time_seconds']['value']


indoor_setpoint_temperature = data_inputs['building_properties']['indoor_setpoint_temperature_K']['value']


new_build_house_roof_area = data_inputs_buildings['new_build_house']['roof_area']['value']
new_build_house_wall_U_value = data_inputs_buildings['new_build_house']['wall_U_value']['value']
new_build_house_roof_U_value = data_inputs_buildings['new_build_house']['roof_U_value']['value']
new_build_house_wall_area = data_inputs_buildings['new_build_house']['wall_area']['value']


larch_lecture_roof_area = data_inputs_buildings['larch_Lecture_theatre']['roof_area']['value']
larch_lecture_wall_area = data_inputs_buildings['larch_Lecture_theatre']['wall_area']['value']
larch_lecture_wall_U_value = data_inputs_buildings['larch_Lecture_theatre']['wall_U_value']['value']
larch_lecture_roof_U_value = data_inputs_buildings['larch_Lecture_theatre']['roof_U_value']['value']
    

warehouse_roof_area = data_inputs_buildings['warehouse']['roof_area']['value']
warehouse_wall_area = data_inputs_buildings['warehouse']['wall_area']['value']
warehouse_wall_U_value = data_inputs_buildings['warehouse']['wall_U_value']['value']
warehouse_roof_U_value = data_inputs_buildings['warehouse']['roof_U_value']['value']


delta_t_ambient =  [temp - indoor_setpoint_temperature for temp in t_ambient]   
Q_load_new_build = np.abs([((new_build_house_wall_area * new_build_house_wall_U_value * t) + (new_build_house_roof_area * new_build_house_roof_U_value * t)) for t in delta_t_ambient])
Q_load_larch_lecture = np.abs([((larch_lecture_wall_area * larch_lecture_wall_U_value * t) + (larch_lecture_roof_area * larch_lecture_roof_U_value * t)) for t in delta_t_ambient])
Q_load_warehouse = np.abs([((warehouse_wall_area * warehouse_wall_U_value * t) + (warehouse_roof_area * warehouse_roof_U_value * t)) for t in delta_t_ambient])

'''
----------------------------------------------------------------------------------------------------------------------
'''
# Constants for the simulation
n_steps = time_step

time_step = total_time/n_steps

# Initialize variables
T_tank = initial_tank_temperature
temperature_array = np.zeros(n_steps)
time_array = np.arange(0, total_time, time_step)
heat_pump_status = [False]  

def heat_pump(t_tank, heat_pump_status):

    # Calculate the heat transfer if the pump is on
    Q_transfer = overall_heat_transfer_coefficient * heat_transfer_area * (fixed_condenser_temperature - t_tank)

    # Check the current tank temperature and update the pump status
    if t_tank < on_temperature_threshold:
        heat_pump_status = True  # Turn on the heat pump
     
        
    elif t_tank >= off_temperature_threshold:
        heat_pump_status = False  # Turn off the heat pump
       

    # Return heat transfer based on pump status
    if heat_pump_status == True:
        return Q_transfer, heat_pump_status
    else:
        return 0 , heat_pump_status  # No heat transfer when the pump is off




'''
---------------------------------------------------------------------------------------------
'''
tank_surface_area = 2

# Initialize the Heat transfer, load and loss lists
current_list = []
loss_list = []
load_list = []
transfer_list = []
time_hours = time_array / 3600

def tank_temperature_ode(t, y, heat_pump_status):
    t_tank = y[0]  # Unpack the tank temperature from the state vector
    
    current_hour = int(t // 3600)
    
    # Assign the current ambient temperature from the list of hours
    t_ambient_current = t_ambient[current_hour]
    delta_t_ambient_current = t_ambient_current - indoor_setpoint_temperature
    current_list.append(t_ambient_current)  
    
    # Get heat transfer from the heat pump
    Q_transfer, heat_pump_status[0] = heat_pump(t_tank, heat_pump_status[0])
    transfer_list.append(Q_transfer)
    
    # Calculate heat load and heat loss
    Q_load_current_new_build = np.abs([((new_build_house_wall_area * new_build_house_wall_U_value * delta_t_ambient_current) + (new_build_house_roof_area * new_build_house_roof_U_value * delta_t_ambient_current))])
    Q_load_current_larch_lecture = np.abs([((larch_lecture_wall_area * larch_lecture_wall_U_value * delta_t_ambient_current) + (larch_lecture_roof_area * larch_lecture_roof_U_value * delta_t_ambient_current))])
    Q_load_current_warehouse = np.abs([((warehouse_wall_area * warehouse_wall_U_value * delta_t_ambient_current) + (warehouse_roof_area * warehouse_roof_U_value * delta_t_ambient_current))])
    load_list.append([Q_load_current_new_build, Q_load_current_larch_lecture, Q_load_current_warehouse])

    
    Q_loss = float(heat_loss_coefficient * tank_surface_area * (t_tank - t_ambient_current))
    loss_list.append(Q_loss)
    
    # Calculate the rate of temperature change (dT/dt)
    dT_tank_dt = (Q_transfer -Q_loss - (Q_load_current_new_build + Q_load_current_larch_lecture + Q_load_current_warehouse)) / (mass_of_water * specific_heat_capacity)
    
    return [dT_tank_dt], heat_pump_status[0]  # Return both dT/dt and updated heat pump status

        
'''
------------------------------------------------------------------------------------------------------------------
'''
# Total energy used by the heat pump over 24 hours
total_energy_joules = np.sum(transfer_list) * time_step  # Summing Q_transfer * time_step to get total energy in joules
total_energy_kwh = total_energy_joules / 3_600_000  # Convert joules to kWh



# Calculate the maximum power output of the heat pump
max_thermal_output = max(transfer_list)

# Calculate total useful thermal energy needed by the building over 24 hours (in joules)
total_useful_energy_joules = np.sum(load_list) * time_step  # Joules
total_useful_energy_kwh = total_useful_energy_joules / 3_600_000  # Convert to kWh

# Calculate system efficiency as the ratio of useful energy to electrical energy input
system_efficiency = (total_useful_energy_kwh / total_energy_kwh) * 100  # Efficiency as a percentage


'''
---------------------------------------------------------------------------------------------------------------------------
'''
